/*
 * TD Ameritrade API
 *
 * TD Ameritrade API
 *
 * API version: 3.0.1
 * Contact: austin.millan@gmail.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PriceHistoryApiService PriceHistoryApi service
type PriceHistoryApiService service

/*
GetPriceHistory Historical price data for charts
Get price history for a symbol
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apikey API Key
 * @param symbol Enter one symbol
 * @param periodType The type of period to show. Valid values are day, month, year, or ytd (year to date). Default is day.
 * @param period The number of periods to show.  Example: For a 2 day / 1 min chart, the values would be: period: 2 periodType: day frequency: 1 frequencyType: min Valid periods by periodType (defaults marked with an asterisk): day: 1, 2, 3, 4, 5, 10* month: 1*, 2, 3, 6 year: 1*, 2, 3, 5, 10, 15, 20 ytd: 1*
 * @param frequencyType The type of frequency with which a new candle is formed.  Valid frequencyTypes by periodType (defaults marked with an asterisk):  day: minute* month: daily, weekly* year: daily, weekly, monthly* ytd: daily, weekly* 
 * @param frequency The number of the frequencyType to be included in each candle.  Valid frequencies by frequencyType (defaults marked with an asterisk):  minute: 1*, 5, 10, 15, 30 daily: 1* weekly: 1* monthly: 1* 
 * @param endDate End date as milliseconds since epoch. If startDate and endDate are provided, period should not be provided. Default is previous trading day.
 * @param startDate Start date as milliseconds since epoch. If startDate and endDate are provided, period should not be provided.
 * @param needExtendedHoursData true to return extended hours data, false for regular market hours only. Default is true
 * @param x x
@return CandleList
*/
func (a *PriceHistoryApiService) GetPriceHistory(ctx _context.Context, apikey string, symbol string, periodType string, period int32, frequencyType string, frequency int32, endDate string, startDate string, needExtendedHoursData bool, x string) (CandleList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CandleList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/marketdata/{symbol}/pricehistory"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", _neturl.QueryEscape(parameterToString(symbol, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("apikey", parameterToString(apikey, ""))
	localVarQueryParams.Add("periodType", parameterToString(periodType, ""))
	localVarQueryParams.Add("period", parameterToString(period, ""))
	localVarQueryParams.Add("frequencyType", parameterToString(frequencyType, ""))
	localVarQueryParams.Add("frequency", parameterToString(frequency, ""))
	localVarQueryParams.Add("endDate", parameterToString(endDate, ""))
	localVarQueryParams.Add("startDate", parameterToString(startDate, ""))
	localVarQueryParams.Add("needExtendedHoursData", parameterToString(needExtendedHoursData, ""))
	localVarQueryParams.Add("x", parameterToString(x, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
